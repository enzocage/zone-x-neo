<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone X - 2D Fallback</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            color: white;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #game-canvas {
            display: block;
            background-color: #000022;
        }
        
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            z-index: 10;
        }
        
        #ui-container div {
            margin-bottom: 5px;
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 100;
        }
        
        #start-screen h1 {
            color: #00ff00;
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        #start-screen p {
            color: white;
            margin-bottom: 10px;
            max-width: 600px;
            text-align: center;
        }
        
        #start-button {
            background-color: #00aa00;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #start-button:hover {
            background-color: #00cc00;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="ui-container">
            <div id="lives">Leben: <span id="lives-count">5</span></div>
            <div id="blocks">Blocks: <span id="blocks-count">15</span></div>
            <div id="plutonium">Plutonium übrig: <span id="plutonium-count">5</span></div>
            <div id="score">Punkte: <span id="score-count">0</span></div>
            <div id="timer" class="hidden">Timer: <span id="timer-count">20</span></div>
        </div>
        
        <div id="start-screen">
            <h1>Zone X</h1>
            <p>Rasterbasiertes 2D-Spiel mit 64x32 Grid und Level-Progression.</p>
            <p>Sammle alle Plutonium-Elemente und bringe sie zu den Tonnen. Erreiche dann den Ausgang.</p>
            <p>Steuerung: W, A, S, D zum Bewegen, Leertaste zum Platzieren von Blocks, Mausrad zum Zoomen.</p>
            
            <!-- Auswahl zwischen normalem Level und Zufallslevel -->
            <div class="level-type-selection" style="margin: 20px 0;">
                <label style="margin-right: 10px; color: white;">Level-Typ:</label>
                <button id="standard-level-btn" class="selected-btn" style="background-color: #00aa00; color: white; border: none; padding: 5px 10px; margin-right: 5px; border-radius: 3px; cursor: pointer;">Standard Level</button>
                <button id="random-level-btn" style="background-color: #555; color: white; border: none; padding: 5px 10px; margin-right: 5px; border-radius: 3px; cursor: pointer;">Zufallslevel</button>
            </div>
            
            <!-- Dropdown für Standardlevel -->
            <div id="standard-level-options" class="level-selection" style="margin: 20px 0;">
                <label for="level-select" style="margin-right: 10px; color: white;">Level auswählen:</label>
                <select id="level-select" style="padding: 5px; border-radius: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <option value="1">Level 1</option>
                    <option value="2">Level 2</option>
                    <option value="3">Level 3</option>
                    <option value="4">Level 4</option>
                    <option value="5">Level 5</option>
                    <option value="6">Level 6</option>
                    <option value="7">Level 7</option>
                    <option value="8">Level 8</option>
                    <option value="9">Level 9</option>
                    <option value="10">Level 10</option>
                    <option value="11">Level 11</option>
                </select>
            </div>
            
            <!-- Einstellungen für Zufallslevel -->
            <div id="random-level-options" class="level-selection" style="margin: 20px 0; display: none; max-width: 400px;">
                <div style="text-align: left; margin-bottom: 15px; color: #00ff00;">Zufallslevel-Einstellungen:</div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="wall-count" style="color: white; text-align: left; width: 180px;">Wandelemente:</label>
                    <input type="number" id="wall-count" min="50" max="500" value="150" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="50" max="500" value="150" id="wall-count-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="enemy-count" style="color: white; text-align: left; width: 180px;">Gegner:</label>
                    <input type="number" id="enemy-count" min="1" max="20" value="7" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="1" max="20" value="7" id="enemy-count-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="block-count" style="color: white; text-align: left; width: 180px;">Mats:</label>
                    <input type="number" id="block-count" min="5" max="50" value="20" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="5" max="50" value="20" id="block-count-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="barrel-count" style="color: white; text-align: left; width: 180px;">Tonnen:</label>
                    <input type="number" id="barrel-count" min="1" max="10" value="3" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="1" max="10" value="3" id="barrel-count-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="plutonium-count" style="color: white; text-align: left; width: 180px;">Plutonium:</label>
                    <input type="number" id="plutonium-count" min="1" max="10" value="5" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="1" max="10" value="5" id="plutonium-count-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
            </div>
            
            <!-- Audio-Einstellungen -->
            <div style="margin: 20px 0;">
                <label for="sound-toggle" style="color: white; margin-right: 10px;">Sound:</label>
                <button id="sound-toggle" style="background-color: #00aa00; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">An</button>
            </div>
            
            <button id="start-button">Spiel starten</button>
        </div>
    </div>
    
    <script>
        // Grundlegende Konstanten
        let GRID_WIDTH = 64;
        let GRID_HEIGHT = 32;
        const CELL_SIZE = 20; // Pixel pro Zelle - kleiner, um mehr Platz zu haben
        
        // Audio-System
        class AudioManager {
            constructor() {
                this.sounds = {};
                this.soundEnabled = true;
                this.loadSounds();
            }
            
            loadSounds() {
                // Definiere verschiedene Soundeffekte mit Base64-encodierten MP3s
                // Diese kurzen Audiodaten sind direkt im Spiel integriert ohne externe Dateien
                
                // Bewegung - kurzes Klick-Geräusch
                this.sounds.move = new Audio("data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMAVEVOQwAAABcAAABMYXZmNTguNzYuMTAwIGxpYnNuZGZmdhgAAAAA//tAwAAAxEgNwRQAAGmIjg2AEAAB3/ggAjR8EO56IABmx8J+JAQH7xO/LnEBAHOCJGiIiaET8eEABPnhHx8Q+X8EAIH4ICAgBAQEDwgIPggICAQEHxAQEPnhAQEPnz54ICBA8EBAICB88Q+XBAQOcICAhwQICB+8Q+eEPnh8ICHz");
                
                // Block platzieren - härterer Klick-Sound
                this.sounds.placeBlock = new Audio("data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMAVEVOQwAAABcAAABMYXZmNTguNzYuMTAwIGxpYnNuZGZmdhgAAAAA//tAwAAAxHgJwRwMAEoILc2gFAQAQRAQEBAQEBAgICAhwQEBAQOCAgICAgICAgICAgICAgICAgICAgQOCHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQECAgICBAQEBAQP3hAgQEBAQICAgICBAuCAs0IA0RMQCBwghxwh4Q8HzwgICA8EBAQEBAQED94QEBAQECAgICB++f3hA/eECAgIEH7wgQIHz");
                
                // Plutonium aufsammeln - Geiger-Zähler-artiges Geräusch
                this.sounds.collectPlutonium = new Audio("data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMAVEVOQwAAABcAAABMYXZmNTguNzYuMTAwIGxpYnNuZGZmdhgAAAAA//tAwAAAxKUKQYQlAA6Q1hYAgAABE4WqYU9gAMZzEYk3cEwiLYxrEL1IhbREWoLQi1CEIQhCEOCEJwhCEJ84QhCEIQhCELP64sQtiFtYi1sQiLEIQkOLUhahYQtDFrCzFqFhCEJDmFhCwsLUhCELCwhCE4Q54tCF+8LCEIXHCEJD5whCEIdatYWFnCEIQhCEIQnDFC3PCEL3hCeZx7x73Lhy5cuEIS4XM4QnCZlwuEIQvnCF64QvxCFwvaXLhfd7ve5cuFy7wvfC9+");
                
                // Plutonium in Tonne ablegen - "Erfolgs"-Sound
                this.sounds.depositPlutonium = new Audio("data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMAVEVOQwAAABcAAABMYXZmNTguNzYuMTAwIGxpYnNuZGZmdhgAAAAA//tAwAAAxLcFwZwMALJgchjBAAA90IQhCEH7whCEJ84QhCFwhCEIQ5wizWaP/4X/CwszFqCzYWZbULULNhYWFhbcLazYWfwsK34W1C2oQvmsLFixZs1mi1WaxZrP/hZ/Cz+Fn8LP4QhMQtQtQtQsIWHjhCwsLELPGFixZs2axZs1n/xZs1mixZrNms/+EIXP7CEIQ5whCZwhCEOcIXeEL1rCwvrC+sLC+sQtQsIXeIXeIXviF3vi");
                
                // Block aufsammeln - leichtes Aufhebe-Geräusch
                this.sounds.collectBlock = new Audio("data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMAVEVOQwAAABcAAABMYXZmNTguNzYuMTAwIGxpYnNuZGZmdhgAAAAA//tAwAAAxMgM4YwkAKRQLgmAAQABLF7Fy5cuXLF/5YsWLFixYsWbNZrNZotFixZs1mis2VlZWbKysrNlZWVlZsrKzZs2bNmzWaLFixYsWLFixYsX/lixYsWLl8uXLly5cuXLly5cuXLly5cuXLl8uXv/Lly5fLly5e/8uX//Ll/5f/8v/+X//L//ly5fLly+XLl7/y5fLly5e/8uXL//ly//5f/8v/+XLly5e/8uX//Lnwuf");
                
                // Kollision mit Feind - Verletzungs-Sound
                this.sounds.enemyCollision = new Audio("data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMAVEVOQwAAABcAAABMYXZmNTguNzYuMTAwIGxpYnNuZGZmdhgAAAAA//tAwAAAxO8vwZAkAKSIbg5gIAAB8/7/6qqqqqqqqiIiIiIi7uERERERF3cREXe7h3dVVVVVVUREREREXcIiIiIiIiIu7hERERF3u4d3d3d3d7u7u7vu7u6qqqqqqqIiIiIiIiIu4REREXdwiIiIiIu7u7u7u7uqqqqqqqoiIiIiIiIu4REREXERERF3cIiIiLu7u7u7u7urqqqqqqoiIiIiIi7hERF3cIiIu7uHd3d3d1VVVVVVREREREXcIiIiIi7hERF3dw7u7u7u7u7uqqqq");
                
                // Level abgeschlossen - Fanfare
                this.sounds.levelComplete = new Audio("data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMAVEVOQwAAABcAAABMYXZmNTguNzYuMTAwIGxpYnNuZGZmdhgAAAAA//tAwAAAxNoXQZwkALBwbg5gAAAB//Qn6E/SP0J+hfof7d97T9C/QnCE/Qn6E/Qn6E/Qn6D9CcIQnCfIT9J+3p+k/aT9vT9Cfo/30J+hP0HCE4QhOEIQnCEJwhCEIQnCEJwhCEIQhCEIQhCEJwhCEIXf70J+hP0J+hP0H6E/Qn6E/Qn6E/Qn6E/YfvSft6ftH7Tv1vT9v97pP0n7en6E/Qfon3rH3nyfef2j90/aP1H6R+sfqP0j9B+9Y+8/eP2j9R+o/cfpH3n6R+o/UP3H6B+o/SfvP3pP0n7R+wfd/wD+UAABJn4");
                
                // Game Over - düsterer Ton
                this.sounds.gameOver = new Audio("data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMAVEVOQwAAABcAAABMYXZmNTguNzYuMTAwIGxpYnNuZGZmdhgAAAAA//tAwAAAxLcJQZwkAKxAbg5gAAAB///AAABJJJJJJAAACSSSSSSAAAJJJJJJQAABJJJJJJIAAASSSSSSSHFtvTbbbbb2yScbJJJJJJJJJJJJJJLJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJIeWWbcskkkkkkhJJJJJJJJJJJJJJJJIJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ");
                
                // Spielstart - Intro-Sound
                this.sounds.gameStart = new Audio("data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMAVEVOQwAAABcAAABMYXZmNTguNzYuMTAwIGxpYnNuZGZmdhgAAAAA//tAwAAAxSgbMYclAAyI2djAIAABj9P///////////////////////////0/T9P0/T9P03T9N03TdN03TdN13XdV1XVdV1XVdVzNEzRMzMzMzIjMiMyIiIiIiEBAv/////////wEC////AQP////////////////T9P0/T9P0/TdP03TdN03TdN13Xdd13XVdV1XU0MzRMzMzMzIjMiMyIiIiIiEBAv/////////BAv/6fAgIED//////8CAg");
                
                // Timer-Warnung (wenn Plutonium-Zeit niedrig ist) - Alarmsignal
                this.sounds.timerWarning = new Audio("data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMAVEVOQwAAABcAAABMYXZmNTguNzYuMTAwIGxpYnNuZGZmdhgAAAAA//tAwAAAxPUXQZkMAJCJneiAAAAAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==");
            }
            
            playSound(soundName) {
                if (!this.soundEnabled) return;
                
                if (this.sounds[soundName]) {
                    // Sound stoppen falls er noch läuft und von vorne abspielen
                    const sound = this.sounds[soundName];
                    sound.pause();
                    sound.currentTime = 0;
                    sound.play().catch(error => {
                        console.log("Konnte Sound nicht abspielen:", error);
                    });
                }
            }
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                return this.soundEnabled;
            }
        }
        
        // Audio-Manager initialisieren
        const audioManager = new AudioManager();
        
        // Spielzustand
        let currentLevel = 1;
        let maxLevel = 11; // Laut readme.md gibt es 11 CSV-Dateien
        let zoomLevel = 3.0; // Für Mausrad-Zoom
        
        // Farben
        const COLORS = {
            BACKGROUND: '#000022',
            PLAYER: '#00ff00',
            ENEMY: '#ff0000',
            WALL: '#888888',
            PLUTONIUM: '#ffff00',
            BARREL: '#8B4513',
            BLOCK: '#00aaff',
            EXIT: '#ff00ff',
            GRID: '#333333'
        };
        
        // Spielvariablen
        let canvas, ctx;
        let player = { 
            x: 2, 
            y: 2, 
            direction: 0, 
            lastX: 2, 
            lastY: 2,
            // Für gleitende Bewegung
            visualX: 2, 
            visualY: 2,
            moveSpeed: 0.1 // Geschwindigkeit für gleitende Bewegung
        };
        let walls = [];
        let enemies = [];
        let plutonium = [];
        let barrels = [];
        let blocks = [];
        let collectibleBlocks = []; // Aufsammelbare Blocks
        let exit = { x: 15, y: 15 };
        let lives = 5;
        let blocksCount = 15;
        let score = 0;
        let plutoniumTimer = 0;
        let plutoniumCollected = false;
        let exitReached = false;
        let gameRunning = false;
        
        // Input
        let keys = {
            up: false,
            down: false,
            left: false,
            right: false,
            action: false
        };
        
        // CSV-Parser und Level-Loader
        const LEVEL_SYMBOLS = {
            '█': 'wall',         // Wand
            'O': 'start',        // Startposition
            'X': 'exit',         // Ausgang
            'D': 'barrel',       // Tonne
            'K': 'plutonium',    // Plutonium
            'l': 'block',        // Aufsammelbarer Block
            'l/': 'block',       // Aufsammelbarer Block
            'r': 'enemy',        // Gegner
            'R': 'enemy',        // Gegner
            '?': 'bonus',        // Bonus (Leben)
            'ᴗ': 'teleport',     // Teleporter (nicht implementiert)
            'A': 'teleport',     // Teleporter (nicht implementiert)
            'L/': 'block',       // Aufsammelbarer Block
            'M': 'boss',         // Boss (nicht implementiert)
            'I': 'item'          // Item (nicht implementiert)
        };
        
        // Flag für Zufallslevel
        let isRandomLevel = false;
        
        // Initialisierung
        function init() {
            console.log("Initialisiere 2D-Fallback...");
            
            // Canvas einrichten
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            // Canvas an Fenstergröße anpassen
            resizeCanvas();
            
            // Event-Listener
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('wheel', handleMouseWheel); // Zoom mit Mausrad
            
            // Level erstellen
            loadLevel(currentLevel);
            
            // UI aktualisieren
            updateUI();
            
            // Spielschleife starten
            gameRunning = true;
            requestAnimationFrame(gameLoop);
            
            console.log("Spiel initialisiert und gestartet");
        }
        
        // Canvas-Größe anpassen
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // Mausrad-Handler für Zoom
        function handleMouseWheel(e) {
            if (!gameRunning) return;
            
            // Zoom-Faktor ändern
            if (e.deltaY < 0) {
                zoomLevel *= 1.1; // Hineinzoomen
                if (zoomLevel > 3) zoomLevel = 3; // Maximaler Zoom
            } else {
                zoomLevel /= 1.1; // Herauszoomen
                if (zoomLevel < 0.5) zoomLevel = 0.5; // Minimaler Zoom
            }
            
            // Verhindert Scrollen der Seite
            e.preventDefault();
        }
        
        // Level laden
        async function loadLevel(level) {
            console.log(`Level ${level} wird geladen...`);
            
            // Level-spezifische Einstellungen
            resetGame();
            
            // Wenn Zufallslevel gewählt wurde, generiere ein Zufallslevel
            if (isRandomLevel) {
                console.log("Zufallslevel wird generiert statt CSV-Level zu laden");
                generateRandomAccessibleLevel();
                console.log("Prüfe generierte Arrays: Wände:", walls.length, "Gegner:", enemies.length, 
                           "Plutonium:", plutonium.length, "Tonnen:", barrels.length, 
                           "Aufsammelbare Blöcke:", collectibleBlocks.length);
                return;
            }
            
            // Ansonsten versuche, das Level aus der CSV-Datei zu laden
            if (await loadLevelFromCSV(level)) {
                console.log("CSV-Level erfolgreich geladen");
            } else {
                console.log("Fallback: Automatisch generiertes Level wird verwendet");
                // Fallback-Generierung der Level-Elemente bereits in loadLevelFromCSV erledigt
            }
            
            console.log(`Level ${level} geladen`);
        }
        
        // Spiel zurücksetzen
        function resetGame() {
            player.x = 2;
            player.y = 2;
            player.visualX = 2;
            player.visualY = 2;
            player.lastX = 2;
            player.lastY = 2;
            walls = [];
            enemies = [];
            plutonium = [];
            barrels = [];
            blocks = [];
            collectibleBlocks = [];
            exit = { x: GRID_WIDTH - 5, y: GRID_HEIGHT - 5 };
            plutoniumCollected = false;
            plutoniumTimer = 0;
            exitReached = false;
        }
        
        // Level aus CSV-Datei laden
        async function loadLevelFromCSV(levelNumber) {
            try {
                console.log(`Lade Level ${levelNumber} aus CSV...`);
                const response = await fetch(`levels/Zone X Levels - Zone 1-${levelNumber}.csv`);
                
                if (!response.ok) {
                    throw new Error(`Fehler beim Laden des Levels: ${response.status}`);
                }
                
                const csvText = await response.text();
                parseCSVLevel(csvText);
                console.log(`Level ${levelNumber} erfolgreich geladen`);
                return true;
            } catch (error) {
                console.error(`Fehler beim Laden des Levels: ${error}`);
                
                // Fallback: Level automatisch generieren
                console.log("Verwende automatisch generiertes Level...");
                createWalls(levelNumber);
                createEnemies(7 * Math.pow(1.3, levelNumber - 1));
                createPlutionium();
                createBarrels();
                createCollectibleBlocks();
                return false;
            }
        }
        
        // CSV-Level parsen und Spielelemente erstellen
        function parseCSVLevel(csvText) {
            resetGame();
            
            // CSV in Zeilen aufteilen
            const rows = csvText.trim().split('\n');
            const grid = rows.map(row => row.split(','));
            
            // Spielfeld-Größe anpassen
            GRID_WIDTH = grid[0].length;
            GRID_HEIGHT = grid.length;
            
            // Spielelemente platzieren
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    const cell = grid[y][x];
                    
                    if (cell in LEVEL_SYMBOLS) {
                        const type = LEVEL_SYMBOLS[cell];
                        
                        switch (type) {
                            case 'wall':
                                walls.push({ x, y });
                                break;
                            case 'start':
                                player.x = x;
                                player.y = y;
                                player.visualX = x;
                                player.visualY = y;
                                player.lastX = x;
                                player.lastY = y;
                                break;
                            case 'exit':
                                exit = { x, y };
                                break;
                            case 'barrel':
                                barrels.push({ x, y });
                                break;
                            case 'plutonium':
                                plutonium.push({ x, y });
                                break;
                            case 'block':
                                collectibleBlocks.push({ x, y });
                                break;
                            case 'enemy':
                                enemies.push({
                                    x, y,
                                    visualX: x,
                                    visualY: y,
                                    direction: Math.floor(Math.random() * 4),
                                    speed: 1 + Math.random() * 0.5
                                });
                                break;
                            case 'bonus':
                                // Bonus-Leben (wird beim Berühren aufgesammelt)
                                // Implementation später
                                break;
                        }
                    }
                }
            }
            
            // Sicherstellen, dass es genug Plutonium und Tonnen gibt
            if (plutonium.length < 5) {
                const missingPlutonium = 5 - plutonium.length;
                console.log(`Zu wenig Plutonium im Level, füge ${missingPlutonium} hinzu`);
                for (let i = 0; i < missingPlutonium; i++) {
                    addRandomElement('plutonium');
                }
            }
            
            if (barrels.length < 3) {
                const missingBarrels = 3 - barrels.length;
                console.log(`Zu wenig Tonnen im Level, füge ${missingBarrels} hinzu`);
                for (let i = 0; i < missingBarrels; i++) {
                    addRandomElement('barrel');
                }
            }
            
            // Wenn das Level keine Feinde hat, füge welche hinzu
            if (enemies.length === 0) {
                const enemyCount = Math.floor(7 * Math.pow(1.3, currentLevel - 1));
                console.log(`Keine Feinde im Level, füge ${enemyCount} hinzu`);
                createEnemies(enemyCount);
            }
        }
        
        // Zufälliges Element zum Level hinzufügen
        function addRandomElement(type) {
            let x, y;
            let validPosition = false;
            
            while (!validPosition) {
                x = Math.floor(Math.random() * (GRID_WIDTH - 4)) + 2;
                y = Math.floor(Math.random() * (GRID_HEIGHT - 4)) + 2;
                
                if (!isWall(x, y) && !isEnemy(x, y) && !isPlutonium(x, y) && 
                    !isBarrel(x, y) && (x !== player.x || y !== player.y) &&
                    x !== exit.x || y !== exit.y) {
                    validPosition = true;
                }
            }
            
            if (type === 'plutonium') {
                plutonium.push({ x, y });
            } else if (type === 'barrel') {
                barrels.push({ x, y });
            } else if (type === 'block') {
                collectibleBlocks.push({ x, y });
            }
        }
        
        // Level erstellen - Wände
        function createWalls(level) {
            walls = [];
            
            // Außenwände
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    if (x === 0 || x === GRID_WIDTH - 1 || y === 0 || y === GRID_HEIGHT - 1) {
                        walls.push({ x, y });
                    }
                }
            }
            
            // Innenwände werden komplexer mit steigendem Level
            const wallRatio = 0.25 * (1 + 0.2 * (level - 1)); // Erhöht sich um 20% pro Level
            const innerWallCount = Math.floor((GRID_WIDTH - 2) * (GRID_HEIGHT - 2) * wallRatio / 4);
            
            // Labyrinth-ähnliche Wände erstellen
            for (let i = 0; i < innerWallCount; i++) {
                const x = Math.floor(Math.random() * (GRID_WIDTH - 10)) + 5;
                const y = Math.floor(Math.random() * (GRID_HEIGHT - 10)) + 5;
                const length = Math.floor(Math.random() * 10) + 5;
                const horizontal = Math.random() > 0.5;
                
                // Eine Linie aus Wänden erstellen
                for (let j = 0; j < length; j++) {
                    const wallX = horizontal ? x + j : x;
                    const wallY = horizontal ? y : y + j;
                    
                    // Prüfen, ob die Position gültig ist
                    if (wallX > 0 && wallX < GRID_WIDTH - 1 && wallY > 0 && wallY < GRID_HEIGHT - 1) {
                        if (!isWall(wallX, wallY) && (wallX !== player.x || wallY !== player.y)) {
                            walls.push({ x: wallX, y: wallY });
                        }
                    }
                }
            }
        }
        
        // Feinde erstellen
        function createEnemies(count) {
            enemies = [];
            
            for (let i = 0; i < count; i++) {
                let x, y;
                let validPosition = false;
                
                // Finde eine gültige Position
                while (!validPosition) {
                    x = Math.floor(Math.random() * (GRID_WIDTH - 4)) + 2;
                    y = Math.floor(Math.random() * (GRID_HEIGHT - 4)) + 2;
                    
                    // Prüfe, ob Position frei ist
                    if (!isWall(x, y) && (x !== player.x || y !== player.y)) {
                        validPosition = true;
                    }
                }
                
                enemies.push({
                    x, y,
                    visualX: x, // Für gleitende Bewegung
                    visualY: y, // Für gleitende Bewegung
                    direction: Math.floor(Math.random() * 4),
                    speed: 1 + Math.random() * 0.5
                });
            }
        }
        
        // Plutonium erstellen
        function createPlutionium() {
            plutonium = [];
            
            for (let i = 0; i < 5; i++) {
                let x, y;
                let validPosition = false;
                
                while (!validPosition) {
                    x = Math.floor(Math.random() * (GRID_WIDTH - 2)) + 1;
                    y = Math.floor(Math.random() * (GRID_HEIGHT - 2)) + 1;
                    
                    if (!isWall(x, y) && !isEnemy(x, y) && (x !== player.x || y !== player.y)) {
                        validPosition = true;
                    }
                }
                
                plutonium.push({ x, y });
            }
        }
        
        // Tonnen erstellen
        function createBarrels() {
            barrels = [];
            
            for (let i = 0; i < 3; i++) {
                let x, y;
                let validPosition = false;
                
                while (!validPosition) {
                    x = Math.floor(Math.random() * (GRID_WIDTH - 2)) + 1;
                    y = Math.floor(Math.random() * (GRID_HEIGHT - 2)) + 1;
                    
                    if (!isWall(x, y) && !isEnemy(x, y) && !isPlutonium(x, y) && (x !== player.x || y !== player.y)) {
                        validPosition = true;
                    }
                }
                
                barrels.push({ x, y });
            }
        }
        
        // Aufsammelbare Blöcke erstellen
        function createCollectibleBlocks() {
            collectibleBlocks = [];
            
            // 1:200 Verhältnis für Blöcke
            const totalCells = GRID_WIDTH * GRID_HEIGHT;
            const blockCount = Math.floor(totalCells / 200);
            
            for (let i = 0; i < blockCount; i++) {
                let x, y;
                let validPosition = false;
                
                while (!validPosition) {
                    x = Math.floor(Math.random() * (GRID_WIDTH - 4)) + 2;
                    y = Math.floor(Math.random() * (GRID_HEIGHT - 4)) + 2;
                    
                    if (!isWall(x, y) && !isEnemy(x, y) && !isPlutonium(x, y) && 
                        !isBarrel(x, y) && (x !== player.x || y !== player.y)) {
                        validPosition = true;
                    }
                }
                
                collectibleBlocks.push({ x, y });
            }
        }
        
        // Kollisionsabfragen
        function isWall(x, y) {
            return walls.some(wall => wall.x === x && wall.y === y);
        }
        
        function isEnemy(x, y, excludeEnemy = null) {
            return enemies.some(enemy => 
                enemy !== excludeEnemy && 
                Math.floor(enemy.x) === Math.floor(x) && 
                Math.floor(enemy.y) === Math.floor(y)
            );
        }
        
        function isPlutonium(x, y) {
            return plutonium.some(p => p.x === x && p.y === y);
        }
        
        function isBarrel(x, y) {
            return barrels.some(barrel => barrel.x === x && barrel.y === y);
        }
        
        function isBlock(x, y) {
            return blocks.some(block => block.x === x && block.y === y);
        }
        
        function isCollectibleBlock(x, y) {
            return collectibleBlocks.some(block => block.x === x && block.y === y);
        }
        
        // Eingabe-Handler
        function handleKeyDown(e) {
            if (!gameRunning) return;
            
            switch (e.key.toLowerCase()) {
                case 'w': keys.up = true; break;
                case 'a': keys.left = true; break;
                case 's': keys.down = true; break;
                case 'd': keys.right = true; break;
                case ' ': keys.action = true; break;
            }
        }
        
        function handleKeyUp(e) {
            if (!gameRunning) return;
            
            switch (e.key.toLowerCase()) {
                case 'w': keys.up = false; break;
                case 'a': keys.left = false; break;
                case 's': keys.down = false; break;
                case 'd': keys.right = false; break;
                case ' ': 
                    keys.action = false;
                    placeBlock();
                    break;
            }
        }
        
        // Block platzieren
        function placeBlock() {
            if (blocksCount > 0) {
                // Block hinter dem Spieler platzieren
                const dx = player.x - player.lastX;
                const dy = player.y - player.lastY;
                
                if (dx === 0 && dy === 0) return; // Spieler hat sich nicht bewegt
                
                const blockX = player.x - dx;
                const blockY = player.y - dy;
                
                // Prüfen, ob Position gültig ist
                if (!isWall(blockX, blockY) && !isEnemy(blockX, blockY) && !isBarrel(blockX, blockY) && !isBlock(blockX, blockY)) {
                    blocks.push({ x: blockX, y: blockY });
                    blocksCount--;
                    updateUI();
                    audioManager.playSound('placeBlock');
                }
            }
        }
        
        // Spieler bewegen
        function movePlayer() {
            // Aktuelle Position speichern
            player.lastX = player.x;
            player.lastY = player.y;
            
            // Gleitende Bewegung berechnen
            if (Math.abs(player.visualX - player.x) < 0.05 && Math.abs(player.visualY - player.y) < 0.05) {
                // Zielposition fast erreicht, neue Eingabe prüfen
                let newX = player.x;
                let newY = player.y;
                
                if (keys.up) newY--;
                if (keys.down) newY++;
                if (keys.left) newX--;
                if (keys.right) newX++;
                
                // Kollisionsprüfung - Erlaube Betreten von Tonnen, wenn Plutonium getragen wird
                if (!isWall(newX, newY) && 
                    (!isBarrel(newX, newY) || plutoniumCollected) && 
                    !isBlock(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                    
                    // Bewegungssound abspielen, wenn sich die Position geändert hat
                    if (newX !== player.lastX || newY !== player.lastY) {
                        audioManager.playSound('move');
                    }
                }
                
                // Richtung setzen (für Darstellung)
                if (keys.up) player.direction = 0;
                if (keys.right) player.direction = 1;
                if (keys.down) player.direction = 2;
                if (keys.left) player.direction = 3;
            }
            
            // Gleitende Bewegung zur Ziel-Grid-Position
            if (player.visualX !== player.x || player.visualY !== player.y) {
                // X-Bewegung
                if (player.visualX < player.x) {
                    player.visualX += player.moveSpeed;
                    if (player.visualX > player.x) player.visualX = player.x;
                } else if (player.visualX > player.x) {
                    player.visualX -= player.moveSpeed;
                    if (player.visualX < player.x) player.visualX = player.x;
                }
                
                // Y-Bewegung
                if (player.visualY < player.y) {
                    player.visualY += player.moveSpeed;
                    if (player.visualY > player.y) player.visualY = player.y;
                } else if (player.visualY > player.y) {
                    player.visualY -= player.moveSpeed;
                    if (player.visualY < player.y) player.visualY = player.y;
                }
            }
            
            // Block aufsammeln
            const blockIndex = collectibleBlocks.findIndex(
                b => Math.floor(player.visualX) === b.x && Math.floor(player.visualY) === b.y
            );
            if (blockIndex !== -1) {
                collectibleBlocks.splice(blockIndex, 1);
                blocksCount++;
                updateUI();
                audioManager.playSound('collectBlock');
            }
            
            // Prüfe Kollisionen mit anderen Objekten
            checkCollisions();
        }
        
        // Kollisionen prüfen
        function checkCollisions() {
            // Plutonium aufsammeln
            const plutoniumIndex = plutonium.findIndex(
                p => Math.floor(player.visualX) === p.x && Math.floor(player.visualY) === p.y
            );
            if (plutoniumIndex !== -1) {
                plutonium.splice(plutoniumIndex, 1);
                plutoniumCollected = true;
                plutoniumTimer = 20;
                updateUI();
                audioManager.playSound('collectPlutonium');
            }
            
            // Plutonium in Tonne abliefern
            if (plutoniumCollected) {
                const barrelIndex = barrels.findIndex(
                    b => Math.floor(player.visualX) === b.x && Math.floor(player.visualY) === b.y
                );
                if (barrelIndex !== -1) {
                    plutoniumCollected = false;
                    plutoniumTimer = 0;
                    score += 100;
                    updateUI();
                    audioManager.playSound('depositPlutonium');
                }
            }
            
            // Block aufsammeln
            const blockIndex = collectibleBlocks.findIndex(
                b => Math.floor(player.visualX) === b.x && Math.floor(player.visualY) === b.y
            );
            if (blockIndex !== -1) {
                collectibleBlocks.splice(blockIndex, 1);
                blocksCount++;
                updateUI();
                audioManager.playSound('collectBlock');
            }
            
            // Ausgang erreichen
            if (Math.floor(player.visualX) === exit.x && Math.floor(player.visualY) === exit.y && 
                plutonium.length === 0 && !plutoniumCollected) {
                exitReached = true;
                audioManager.playSound('levelComplete');
                
                // Level abgeschlossen, nächstes Level laden
                if (currentLevel < maxLevel) {
                    currentLevel++;
                    setTimeout(() => {
                        loadLevel(currentLevel);
                        gameRunning = true;
                    }, 1500);
                    alert(`Level ${currentLevel-1} geschafft! Nächstes Level wird geladen.`);
                } else {
                    gameRunning = false;
                    alert(`Glückwunsch! Du hast alle Level geschafft mit ${score} Punkten!`);
                }
            }
            
            // Kollision mit Feinden
            if (enemies.some(enemy => 
                Math.abs(enemy.visualX - player.visualX) < 0.5 && 
                Math.abs(enemy.visualY - player.visualY) < 0.5)) {
                loseLife();
            }
        }
        
        // Leben verlieren
        function loseLife() {
            lives--;
            updateUI();
            audioManager.playSound('enemyCollision');
            
            if (lives <= 0) {
                gameRunning = false;
                audioManager.playSound('gameOver');
                alert("Game Over! Du hast " + score + " Punkte erreicht.");
            } else {
                // Spieler zurücksetzen
                player.x = 2;
                player.y = 2;
            }
        }
        
        // Feinde bewegen
        function moveEnemies() {
            for (let enemy of enemies) {
                // Gleitende Bewegung zur Ziel-Grid-Position
                if (Math.abs(enemy.visualX - enemy.x) < 0.05 && 
                    Math.abs(enemy.visualY - enemy.y) < 0.05) {
                    
                    // Mit zufälliger Wahrscheinlichkeit Richtung ändern
                    if (Math.random() < 0.02) {
                        enemy.direction = Math.floor(Math.random() * 4);
                    }
                    
                    // Aktuelle Position merken
                    const oldX = enemy.x;
                    const oldY = enemy.y;
                    
                    // Bewegung basierend auf Richtung
                    switch (enemy.direction) {
                        case 0: enemy.y--; break; // Oben
                        case 1: enemy.x++; break; // Rechts
                        case 2: enemy.y++; break; // Unten
                        case 3: enemy.x--; break; // Links
                    }
                    
                    // Kollisionsprüfung
                    if (isWall(enemy.x, enemy.y) || isBarrel(enemy.x, enemy.y) || 
                        isBlock(enemy.x, enemy.y) || isEnemy(enemy.x, enemy.y, enemy)) {
                        // Zurücksetzen und Richtung ändern
                        enemy.x = oldX;
                        enemy.y = oldY;
                        enemy.direction = Math.floor(Math.random() * 4);
                    }
                }
                
                // Gleitende Bewegung anwenden
                if (enemy.visualX !== enemy.x || enemy.visualY !== enemy.y) {
                    // X-Bewegung
                    if (enemy.visualX < enemy.x) {
                        enemy.visualX += 0.05;
                        if (enemy.visualX > enemy.x) enemy.visualX = enemy.x;
                    } else if (enemy.visualX > enemy.x) {
                        enemy.visualX -= 0.05;
                        if (enemy.visualX < enemy.x) enemy.visualX = enemy.x;
                    }
                    
                    // Y-Bewegung
                    if (enemy.visualY < enemy.y) {
                        enemy.visualY += 0.05;
                        if (enemy.visualY > enemy.y) enemy.visualY = enemy.y;
                    } else if (enemy.visualY > enemy.y) {
                        enemy.visualY -= 0.05;
                        if (enemy.visualY < enemy.y) enemy.visualY = enemy.y;
                    }
                }
                
                // Kollision mit Spieler
                if (Math.abs(enemy.visualX - player.visualX) < 0.5 && 
                    Math.abs(enemy.visualY - player.visualY) < 0.5) {
                    loseLife();
                }
            }
        }
        
        // UI aktualisieren
        function updateUI() {
            document.getElementById('lives-count').textContent = lives;
            document.getElementById('blocks-count').textContent = blocksCount;
            document.getElementById('plutonium-count').textContent = plutonium.length;
            document.getElementById('score-count').textContent = score;
            
            // Timer anzeigen, wenn Plutonium gesammelt
            const timerElement = document.getElementById('timer');
            if (plutoniumCollected) {
                timerElement.classList.remove('hidden');
                document.getElementById('timer-count').textContent = Math.ceil(plutoniumTimer);
            } else {
                timerElement.classList.add('hidden');
            }
        }
        
        // Zeichenfunktionen
        function draw() {
            // Canvas leeren
            ctx.fillStyle = COLORS.BACKGROUND;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Berechne den Viewport-Offset für Zentrierung des Spielers
            const viewportOffsetX = canvas.width / 2 - player.visualX * CELL_SIZE * zoomLevel;
            const viewportOffsetY = canvas.height / 2 - player.visualY * CELL_SIZE * zoomLevel;
            
            // Gitter zeichnen
            drawGrid(viewportOffsetX, viewportOffsetY);
            
            // Spielelemente zeichnen
            drawWalls(viewportOffsetX, viewportOffsetY);
            drawPlutionium(viewportOffsetX, viewportOffsetY);
            drawBarrels(viewportOffsetX, viewportOffsetY);
            drawCollectibleBlocks(viewportOffsetX, viewportOffsetY);
            drawBlocks(viewportOffsetX, viewportOffsetY);
            drawExit(viewportOffsetX, viewportOffsetY);
            drawEnemies(viewportOffsetX, viewportOffsetY);
            drawPlayer(viewportOffsetX, viewportOffsetY);
            
            // Level-Info anzeigen
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.fillText(`Level: ${currentLevel}`, 10, canvas.height - 10);
        }
        
        // Gitter zeichnen
        function drawGrid(offsetX, offsetY) {
            ctx.strokeStyle = COLORS.GRID;
            ctx.lineWidth = 0.5;
            
            // Horizontale Linien
            for (let y = 0; y <= GRID_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(offsetX, offsetY + y * CELL_SIZE * zoomLevel);
                ctx.lineTo(offsetX + GRID_WIDTH * CELL_SIZE * zoomLevel, offsetY + y * CELL_SIZE * zoomLevel);
                ctx.stroke();
            }
            
            // Vertikale Linien
            for (let x = 0; x <= GRID_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(offsetX + x * CELL_SIZE * zoomLevel, offsetY);
                ctx.lineTo(offsetX + x * CELL_SIZE * zoomLevel, offsetY + GRID_HEIGHT * CELL_SIZE * zoomLevel);
                ctx.stroke();
            }
        }
        
        // Wände zeichnen
        function drawWalls(offsetX, offsetY) {
            ctx.fillStyle = COLORS.WALL;
            
            for (let wall of walls) {
                ctx.fillRect(
                    offsetX + wall.x * CELL_SIZE * zoomLevel, 
                    offsetY + wall.y * CELL_SIZE * zoomLevel, 
                    CELL_SIZE * zoomLevel, 
                    CELL_SIZE * zoomLevel
                );
            }
        }
        
        // Spieler zeichnen
        function drawPlayer(offsetX, offsetY) {
            ctx.fillStyle = COLORS.PLAYER;
            
            // Spielerkörper zeichnen (Kreis)
            ctx.beginPath();
            ctx.arc(
                offsetX + player.visualX * CELL_SIZE * zoomLevel + CELL_SIZE * zoomLevel / 2,
                offsetY + player.visualY * CELL_SIZE * zoomLevel + CELL_SIZE * zoomLevel / 2,
                CELL_SIZE * zoomLevel / 2 - 2,
                0, 
                Math.PI * 2
            );
            ctx.fill();
            
            // Richtungsanzeige
            ctx.fillStyle = '#000';
            const dirX = Math.cos(player.direction * Math.PI / 2);
            const dirY = Math.sin(player.direction * Math.PI / 2);
            
            ctx.beginPath();
            ctx.arc(
                offsetX + player.visualX * CELL_SIZE * zoomLevel + CELL_SIZE * zoomLevel / 2 + dirX * CELL_SIZE * zoomLevel / 4,
                offsetY + player.visualY * CELL_SIZE * zoomLevel + CELL_SIZE * zoomLevel / 2 + dirY * CELL_SIZE * zoomLevel / 4,
                CELL_SIZE * zoomLevel / 6,
                0, 
                Math.PI * 2
            );
            ctx.fill();
        }
        
        // Feinde zeichnen
        function drawEnemies(offsetX, offsetY) {
            ctx.fillStyle = COLORS.ENEMY;
            
            for (let enemy of enemies) {
                // Feindkörper (Quadrat mit abgerundeten Ecken)
                const x = offsetX + enemy.visualX * CELL_SIZE * zoomLevel;
                const y = offsetY + enemy.visualY * CELL_SIZE * zoomLevel;
                const size = CELL_SIZE * zoomLevel - 4;
                const radius = 5 * zoomLevel;
                
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + size - radius, y);
                ctx.quadraticCurveTo(x + size, y, x + size, y + radius);
                ctx.lineTo(x + size, y + size - radius);
                ctx.quadraticCurveTo(x + size, y + size, x + size - radius, y + size);
                ctx.lineTo(x + radius, y + size);
                ctx.quadraticCurveTo(x, y + size, x, y + size - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
                
                // Augen
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x + size / 3, y + size / 3, size / 10, 0, Math.PI * 2);
                ctx.arc(x + size * 2/3, y + size / 3, size / 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = COLORS.ENEMY;
            }
        }
        
        // Aufsammelbare Blöcke zeichnen
        function drawCollectibleBlocks(offsetX, offsetY) {
            ctx.fillStyle = COLORS.BLOCK;
            ctx.globalAlpha = 0.7; // Transparenter als platzierte Blocks
            
            for (let block of collectibleBlocks) {
                ctx.fillRect(
                    offsetX + block.x * CELL_SIZE * zoomLevel + 5 * zoomLevel,
                    offsetY + block.y * CELL_SIZE * zoomLevel + 5 * zoomLevel,
                    CELL_SIZE * zoomLevel - 10 * zoomLevel,
                    CELL_SIZE * zoomLevel - 10 * zoomLevel
                );
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        // Plutonium zeichnen
        function drawPlutionium(offsetX, offsetY) {
            ctx.fillStyle = COLORS.PLUTONIUM;
            
            for (let p of plutonium) {
                const centerX = offsetX + p.x * CELL_SIZE * zoomLevel + CELL_SIZE * zoomLevel / 2;
                const centerY = offsetY + p.y * CELL_SIZE * zoomLevel + CELL_SIZE * zoomLevel / 2;
                const radius = CELL_SIZE * zoomLevel / 3;
                
                // Strahlendes Plutonium zeichnen
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = i * Math.PI / 4;
                    const innerRadius = radius / 2;
                    
                    ctx.lineTo(
                        centerX + Math.cos(angle) * radius,
                        centerY + Math.sin(angle) * radius
                    );
                    
                    ctx.lineTo(
                        centerX + Math.cos(angle + Math.PI / 8) * innerRadius,
                        centerY + Math.sin(angle + Math.PI / 8) * innerRadius
                    );
                }
                ctx.closePath();
                ctx.fill();
            }
            
            // Anzeige für gesammeltes Plutonium
            if (plutoniumCollected) {
                ctx.fillStyle = COLORS.PLUTONIUM;
                ctx.beginPath();
                ctx.arc(
                    offsetX + player.visualX * CELL_SIZE * zoomLevel + CELL_SIZE * zoomLevel / 2,
                    offsetY + player.visualY * CELL_SIZE * zoomLevel - CELL_SIZE * zoomLevel / 4,
                    CELL_SIZE * zoomLevel / 6,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        }
        
        // Tonnen zeichnen
        function drawBarrels(offsetX, offsetY) {
            ctx.fillStyle = COLORS.BARREL;
            
            for (let barrel of barrels) {
                const x = offsetX + barrel.x * CELL_SIZE * zoomLevel + 2 * zoomLevel;
                const y = offsetY + barrel.y * CELL_SIZE * zoomLevel + 2 * zoomLevel;
                const width = CELL_SIZE * zoomLevel - 4 * zoomLevel;
                const height = CELL_SIZE * zoomLevel - 4 * zoomLevel;
                
                // Tonne zeichnen
                ctx.fillRect(x, y, width, height);
                
                // Details hinzufügen
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2 * zoomLevel;
                ctx.beginPath();
                ctx.moveTo(x, y + height / 3);
                ctx.lineTo(x + width, y + height / 3);
                ctx.moveTo(x, y + height * 2/3);
                ctx.lineTo(x + width, y + height * 2/3);
                ctx.stroke();
            }
        }
        
        // Blocks zeichnen
        function drawBlocks(offsetX, offsetY) {
            ctx.fillStyle = COLORS.BLOCK;
            
            for (let block of blocks) {
                ctx.fillRect(
                    offsetX + block.x * CELL_SIZE * zoomLevel + 2 * zoomLevel,
                    offsetY + block.y * CELL_SIZE * zoomLevel + 2 * zoomLevel,
                    CELL_SIZE * zoomLevel - 4 * zoomLevel,
                    CELL_SIZE * zoomLevel - 4 * zoomLevel
                );
            }
        }
        
        // Ausgang zeichnen
        function drawExit(offsetX, offsetY) {
            const x = offsetX + exit.x * CELL_SIZE * zoomLevel;
            const y = offsetY + exit.y * CELL_SIZE * zoomLevel;
            
            // Exit pulsiert, wenn alle Plutoniumproben abgeliefert wurden
            if (plutonium.length === 0 && !plutoniumCollected) {
                const pulseSize = 0.1 * Math.sin(Date.now() / 200) + 1.0;
                
                ctx.fillStyle = COLORS.EXIT;
                ctx.fillRect(
                    x + CELL_SIZE * zoomLevel / 2 * (1 - pulseSize),
                    y + CELL_SIZE * zoomLevel / 2 * (1 - pulseSize),
                    CELL_SIZE * zoomLevel * pulseSize,
                    CELL_SIZE * zoomLevel * pulseSize
                );
            } else {
                ctx.fillStyle = '#333';
                ctx.fillRect(x, y, CELL_SIZE * zoomLevel, CELL_SIZE * zoomLevel);
                
                ctx.fillStyle = COLORS.EXIT;
                ctx.fillRect(
                    x + 5 * zoomLevel, 
                    y + 5 * zoomLevel, 
                    CELL_SIZE * zoomLevel - 10 * zoomLevel, 
                    CELL_SIZE * zoomLevel - 10 * zoomLevel
                );
            }
        }
        
        // Spielschleife
        let lastTime = 0;
        function gameLoop(timestamp) {
            // Delta-Zeit berechnen
            const deltaTime = (timestamp - lastTime) / 1000; // in Sekunden
            lastTime = timestamp;
            
            // Spiellogik nur aktualisieren, wenn das Spiel läuft
            if (gameRunning) {
                movePlayer();
                moveEnemies();
                
                // Plutonium-Timer aktualisieren
                if (plutoniumCollected) {
                    plutoniumTimer -= deltaTime;
                    
                    // Warnungssound abspielen, wenn weniger als 5 Sekunden übrig sind
                    if (plutoniumTimer <= 5 && plutoniumTimer > 0 && Math.floor(plutoniumTimer * 2) % 2 === 0) {
                        audioManager.playSound('timerWarning');
                    }
                    
                    if (plutoniumTimer <= 0) {
                        plutoniumCollected = false;
                        plutoniumTimer = 0;
                        loseLife();
                    }
                    
                    updateUI();
                }
            }
            
            // Zeichnen
            draw();
            
            // Nächsten Frame anfordern
            requestAnimationFrame(gameLoop);
        }
        
        // Start-Button-Handler
        document.getElementById('start-button').addEventListener('click', function() {
            console.log("Start-Button geklickt, isRandomLevel =", isRandomLevel);
            
            if (isRandomLevel) {
                // Bei Zufallslevel wird kein Level-Index benötigt
                currentLevel = 1; // Setze trotzdem auf 1, falls später benötigt
                console.log("Zufallslevel ausgewählt");
            } else {
                // Level aus dem Dropdown-Menü holen
                const levelSelect = document.getElementById('level-select');
                currentLevel = parseInt(levelSelect.value);
                console.log("Standard-Level ausgewählt:", currentLevel);
            }
            
            document.getElementById('start-screen').classList.add('hidden');
            audioManager.playSound('gameStart');
            init();
        });
        
        // Handler für Wechsel zwischen Standard- und Zufallslevel
        document.getElementById('standard-level-btn').addEventListener('click', function() {
            isRandomLevel = false;
            document.getElementById('standard-level-options').style.display = 'block';
            document.getElementById('random-level-options').style.display = 'none';
            document.getElementById('standard-level-btn').style.backgroundColor = '#00aa00';
            document.getElementById('random-level-btn').style.backgroundColor = '#555';
        });
        
        document.getElementById('random-level-btn').addEventListener('click', function() {
            isRandomLevel = true;
            document.getElementById('standard-level-options').style.display = 'none';
            document.getElementById('random-level-options').style.display = 'block';
            document.getElementById('standard-level-btn').style.backgroundColor = '#555';
            document.getElementById('random-level-btn').style.backgroundColor = '#00aa00';
        });
        
        // Slider und Input-Feld synchronisieren
        function setupSliderInputSync(sliderId, inputId) {
            const slider = document.getElementById(sliderId);
            const input = document.getElementById(inputId);
            
            slider.addEventListener('input', function() {
                input.value = slider.value;
            });
            
            input.addEventListener('input', function() {
                if (input.value < input.min) input.value = input.min;
                if (input.value > input.max) input.value = input.max;
                slider.value = input.value;
            });
        }
        
        // Synchronisierung für alle Slider einrichten
        window.addEventListener('DOMContentLoaded', function() {
            setupSliderInputSync('wall-count-slider', 'wall-count');
            setupSliderInputSync('enemy-count-slider', 'enemy-count');
            setupSliderInputSync('block-count-slider', 'block-count');
            setupSliderInputSync('barrel-count-slider', 'barrel-count');
            setupSliderInputSync('plutonium-count-slider', 'plutonium-count');
        });
        
        // Zufälliges Level generieren mit sichergestellter Zugänglichkeit
        function generateRandomAccessibleLevel() {
            console.log("Generiere zufälliges Level mit garantierter Zugänglichkeit...");
            
            // Spielfeldgröße auf Standard setzen
            GRID_WIDTH = 64;
            GRID_HEIGHT = 32;
            
            // Werte aus den Einstellungen holen
            const wallCount = parseInt(document.getElementById("wall-count").value) || 550;
            const enemyCount = parseInt(document.getElementById("enemy-count").value) || 47;
            const blockCount = parseInt(document.getElementById("block-count").value) || 20;
            const barrelCount = parseInt(document.getElementById("barrel-count").value) || 3;
            const plutoniumCount = parseInt(document.getElementById("plutonium-count").value) || 5;
            
            console.log(`Einstellungen: Wände=${wallCount}, Gegner=${enemyCount}, Blöcke=${blockCount}, Tonnen=${barrelCount}, Plutonium=${plutoniumCount}`);
            
            // Arrays zurücksetzen
            walls = [];
            enemies = [];
            plutonium = [];
            barrels = [];
            blocks = [];
            collectibleBlocks = [];
            
            // Spieler und Ausgang positionieren
            player.x = 2;
            player.y = 2;
            player.visualX = 2;
            player.visualY = 2;
            player.lastX = 2;
            player.lastY = 2;
            
            exit = { x: GRID_WIDTH - 5, y: GRID_HEIGHT - 5 };
            
            // Außenwände erstellen
            createBorderWalls();
            console.log(`Außenwände erstellt: ${walls.length} Wandelemente`);
            
            // Wandelemente erstellen und Erreichbarkeit sicherstellen
            createAccessibleWalls(wallCount);
            console.log(`Innenwände erstellt: ${walls.length - (GRID_WIDTH * 2 + GRID_HEIGHT * 2 - 4)} von ${wallCount} angeforderten Wandelementen`);
            
            let placedEnemies = 0;
            let placedPlutonium = 0;
            let placedBarrels = 0;
            let placedBlocks = 0;
            
            // Gegner platzieren
            console.log(`Versuche, ${enemyCount} Gegner zu platzieren...`);
            for (let i = 0; i < enemyCount; i++) {
                if (placeRandomElement('enemy')) {
                    placedEnemies++;
                }
            }
            console.log(`Gegner platziert: ${enemies.length} von ${enemyCount}`);
            
            // Plutonium platzieren
            console.log(`Versuche, ${plutoniumCount} Plutonium zu platzieren...`);
            for (let i = 0; i < plutoniumCount; i++) {
                if (placeRandomElement('plutonium')) {
                    placedPlutonium++;
                }
            }
            console.log(`Plutonium platziert: ${plutonium.length} von ${plutoniumCount}`);
            
            // Tonnen platzieren
            console.log(`Versuche, ${barrelCount} Tonnen zu platzieren...`);
            for (let i = 0; i < barrelCount; i++) {
                if (placeRandomElement('barrel')) {
                    placedBarrels++;
                }
            }
            console.log(`Tonnen platziert: ${barrels.length} von ${barrelCount}`);
            
            // Blöcke platzieren
            console.log(`Versuche, ${blockCount} Blöcke zu platzieren...`);
            for (let i = 0; i < blockCount; i++) {
                if (placeRandomElement('block')) {
                    placedBlocks++;
                }
            }
            console.log(`Blöcke platziert: ${collectibleBlocks.length} von ${blockCount}`);
            
            // Startblöcke setzen
            blocksCount = 15;
            
            // Alternativ: Zwangsplatzierung, falls nicht genug Elemente platziert wurden
            // Dies stellt sicher, dass das Level immer genügend Elemente enthält
            if (placedPlutonium === 0) {
                console.log("WARNUNG: Keine Plutonium-Elemente platziert. Füge einige mit weniger strengen Kriterien hinzu.");
                forcePlaceElements('plutonium', Math.max(1, plutoniumCount / 2));
            }
            
            if (placedBarrels === 0) {
                console.log("WARNUNG: Keine Tonnen platziert. Füge einige mit weniger strengen Kriterien hinzu.");
                forcePlaceElements('barrel', Math.max(1, barrelCount / 2));
            }
            
            // Debugging: Prüfe, ob im Level-Grid Elemente korrekt platziert sind
            let gridDebug = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill('.'));
            
            // Markiere alle Elemente im Debug-Grid
            walls.forEach(w => { if(w.x >= 0 && w.x < GRID_WIDTH && w.y >= 0 && w.y < GRID_HEIGHT) gridDebug[w.y][w.x] = '█'; });
            enemies.forEach(e => { if(e.x >= 0 && e.x < GRID_WIDTH && e.y >= 0 && e.y < GRID_HEIGHT) gridDebug[e.y][e.x] = 'E'; });
            plutonium.forEach(p => { if(p.x >= 0 && p.x < GRID_WIDTH && p.y >= 0 && p.y < GRID_HEIGHT) gridDebug[p.y][p.x] = 'P'; });
            barrels.forEach(b => { if(b.x >= 0 && b.x < GRID_WIDTH && b.y >= 0 && b.y < GRID_HEIGHT) gridDebug[b.y][b.x] = 'B'; });
            collectibleBlocks.forEach(c => { if(c.x >= 0 && c.x < GRID_WIDTH && c.y >= 0 && c.y < GRID_HEIGHT) gridDebug[c.y][c.x] = 'C'; });
            gridDebug[player.y][player.x] = 'O';
            gridDebug[exit.y][exit.x] = 'X';
            
            // Zähle Elemente im Grid
            let counts = {
                walls: 0,
                enemies: 0,
                plutonium: 0,
                barrels: 0,
                blocks: 0
            };
            
            for(let y = 0; y < GRID_HEIGHT; y++) {
                for(let x = 0; x < GRID_WIDTH; x++) {
                    if(gridDebug[y][x] === '█') counts.walls++;
                    else if(gridDebug[y][x] === 'E') counts.enemies++;
                    else if(gridDebug[y][x] === 'P') counts.plutonium++;
                    else if(gridDebug[y][x] === 'B') counts.barrels++;
                    else if(gridDebug[y][x] === 'C') counts.blocks++;
                }
            }
            
            console.log("Grid-Elemente-Zählung:", counts);
            console.log("Zufälliges Level erfolgreich generiert");
        }
        
        // Elemente mit weniger strengen Kriterien platzieren (Notfall-Funktion)
        function forcePlaceElements(type, count) {
            console.log(`Force-Platzierung: Versuche, ${count} ${type}-Elemente zu platzieren...`);
            let placed = 0;
            
            for (let i = 0; i < count; i++) {
                let x, y;
                let foundPosition = false;
                
                // Suche nach irgendwelchen freien Positions
                for (let attempt = 0; attempt < 50; attempt++) {
                    x = Math.floor(Math.random() * (GRID_WIDTH - 4)) + 2;
                    y = Math.floor(Math.random() * (GRID_HEIGHT - 4)) + 2;
                    
                    // Nur grundlegende Überprüfungen
                    if (!isWall(x, y) && !isEnemy(x, y) && !isPlutonium(x, y) && !isBarrel(x, y) && 
                        (x !== player.x || y !== player.y) && (x !== exit.x || y !== exit.y)) {
                        foundPosition = true;
                        break;
                    }
                }
                
                if (foundPosition) {
                    // Element basierend auf Typ erstellen
                    switch (type) {
                        case 'enemy':
                            enemies.push({
                                x, y,
                                visualX: x,
                                visualY: y,
                                direction: Math.floor(Math.random() * 4),
                                speed: 1 + Math.random() * 0.5
                            });
                            break;
                        case 'plutonium':
                            plutonium.push({ x, y });
                            break;
                        case 'barrel':
                            barrels.push({ x, y });
                            break;
                        case 'block':
                            collectibleBlocks.push({ x, y });
                            break;
                    }
                    placed++;
                    console.log(`Force-platziert: ${type} an Position (${x},${y})`);
                }
            }
            
            console.log(`Force-Platzierung: ${placed} von ${count} ${type}-Elementen platziert`);
        }
        
        // Zufälliges Element platzieren
        function placeRandomElement(type) {
            let x, y;
            let validPosition = false;
            
            // Maximale Anzahl von Versuchen, eine gültige Position zu finden
            let attempts = 0;
            const maxAttempts = 100;
            
            console.log(`Versuche, ein Element vom Typ ${type} zu platzieren...`);
            
            while (!validPosition && attempts < maxAttempts) {
                attempts++;
                
                x = Math.floor(Math.random() * (GRID_WIDTH - 4)) + 2;
                y = Math.floor(Math.random() * (GRID_HEIGHT - 4)) + 2;
                
                // Prüfen, ob die Position bereits belegt ist
                const isPositionOccupied = isWall(x, y) || 
                                         isEnemy(x, y) || 
                                         isPlutonium(x, y) || 
                                         isBarrel(x, y) || 
                                         isCollectibleBlock(x, y);
                
                // Prüfen, ob die Position mit Spieler oder Ausgang kollidiert
                const isPlayerOrExit = (x === player.x && y === player.y) || 
                                      (x === exit.x && y === exit.y);
                
                // Prüfen, ob die Position zu nah am Spieler oder Ausgang ist
                // Toleranzbereich deutlich reduzieren, um mehr valide Positionen zu finden
                const isTooCloseToPlayer = Math.abs(x - player.x) < 2 && Math.abs(y - player.y) < 2;
                const isTooCloseToExit = Math.abs(x - exit.x) < 2 && Math.abs(y - exit.y) < 2;
                
                if (isPositionOccupied || isPlayerOrExit || isTooCloseToPlayer || isTooCloseToExit) {
                    if (attempts % 20 === 0) {
                        console.log(`Versuch ${attempts}/${maxAttempts} für ${type}: Position (${x},${y}) ist nicht gültig.`);
                        console.log(`  - Belegt: ${isPositionOccupied}, Spieler/Ausgang: ${isPlayerOrExit}, Nähe Spieler: ${isTooCloseToPlayer}, Nähe Ausgang: ${isTooCloseToExit}`);
                    }
                    continue;
                }
                
                validPosition = true;
                console.log(`Gültige Position für ${type} gefunden: (${x},${y}) nach ${attempts} Versuchen.`);
            }
            
            if (!validPosition) {
                console.warn(`Konnte keine gültige Position für ${type} finden nach ${maxAttempts} Versuchen.`);
                return false;
            }
            
            // Element basierend auf Typ erstellen
            switch (type) {
                case 'enemy':
                    enemies.push({
                        x, y,
                        visualX: x,
                        visualY: y,
                        direction: Math.floor(Math.random() * 4),
                        speed: 1 + Math.random() * 0.5
                    });
                    break;
                case 'plutonium':
                    plutonium.push({ x, y });
                    break;
                case 'barrel':
                    barrels.push({ x, y });
                    break;
                case 'block':
                    collectibleBlocks.push({ x, y });
                    break;
            }
            
            console.log(`Element vom Typ ${type} an Position (${x},${y}) platziert`);
            return true;
        }
        
        // Außenwände erstellen
        function createBorderWalls() {
            console.log("Erstelle Außenwände...");
            
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    if (x === 0 || x === GRID_WIDTH - 1 || y === 0 || y === GRID_HEIGHT - 1) {
                        walls.push({ x, y });
                    }
                }
            }
            console.log(`${GRID_WIDTH * 2 + GRID_HEIGHT * 2 - 4} Außenwand-Elemente erstellt`);
        }
        
        // Wandelemente erstellen mit garantierter Zugänglichkeit
        function createAccessibleWalls(count) {
            // Versuche, so viele Wände wie möglich zu platzieren
            let placedWalls = 0;
            let maxAttempts = count * 3; // Mehr Versuche als tatsächlich benötigte Wände
            
            console.log(`Versuche, ${count} Wände zu platzieren mit maximal ${maxAttempts} Versuchen`);
            
            for (let i = 0; i < maxAttempts && placedWalls < count; i++) {
                // Zufällige Position für Wandelement
                const x = Math.floor(Math.random() * (GRID_WIDTH - 4)) + 2;
                const y = Math.floor(Math.random() * (GRID_HEIGHT - 4)) + 2;
                
                // Prüfe, ob Position bereits belegt ist oder zu nah am Spieler/Ausgang
                if (isWall(x, y) || 
                    (x === player.x && y === player.y) ||
                    (x === exit.x && y === exit.y) ||
                    (Math.abs(x - player.x) < 3 && Math.abs(y - player.y) < 3) || 
                    (Math.abs(x - exit.x) < 3 && Math.abs(y - exit.y) < 3)) {
                    continue;
                }
                
                // Füge Wand temporär hinzu
                walls.push({ x, y });
                
                // Prüfe, ob das Level noch zugänglich ist
                if (!isLevelAccessible()) {
                    // Wenn nicht, entferne die letzte Wand wieder
                    walls.pop();
                    continue;
                }
                
                // Wand erfolgreich platziert
                placedWalls++;
                
                if (placedWalls % 20 === 0 || placedWalls === count) {
                    console.log(`${placedWalls} von ${count} Wänden platziert (Versuch ${i+1})`);
                }
            }
            
            console.log(`Insgesamt ${placedWalls} von ${count} angeforderten Wandelementen platziert`);
        }
        
        // Level-Zugänglichkeit prüfen
        function isLevelAccessible() {
            // Wir erstellen eine Kopie des Grids und markieren erreichbare Zellen
            // 0 = unbesucht, 1 = besucht, 2 = Wand
            const grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
            
            // Wände markieren
            for (let wall of walls) {
                if (wall.x >= 0 && wall.x < GRID_WIDTH && wall.y >= 0 && wall.y < GRID_HEIGHT) {
                    grid[wall.y][wall.x] = 2;
                }
            }
            
            // Startpunkt markieren
            const queue = [{ x: player.x, y: player.y }];
            grid[player.y][player.x] = 1;
            
            // Besuche alle erreichbaren Zellen mit Breitensuche
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Nachbarzellen überprüfen
                const neighbors = [
                    { x: current.x, y: current.y - 1 }, // Oben
                    { x: current.x + 1, y: current.y }, // Rechts
                    { x: current.x, y: current.y + 1 }, // Unten
                    { x: current.x - 1, y: current.y }  // Links
                ];
                
                for (let neighbor of neighbors) {
                    // Prüfen, ob im Spielfeld und noch nicht besucht und keine Wand
                    if (neighbor.x >= 0 && neighbor.x < GRID_WIDTH && 
                        neighbor.y >= 0 && neighbor.y < GRID_HEIGHT && 
                        grid[neighbor.y][neighbor.x] === 0) {
                        
                        grid[neighbor.y][neighbor.x] = 1;
                        queue.push(neighbor);
                    }
                }
            }
            
            // Prüfen, ob der Ausgang erreichbar ist
            if (grid[exit.y][exit.x] !== 1) {
                console.log("Der Ausgang ist nicht erreichbar, verwerfe diese Wandplatzierung.");
                return false;
            }
            
            // Prüfen, ob genug freier Platz für Gegner, Plutonium, etc. verfügbar ist
            const minFreeSpace = 200; // Mindestanzahl freier Zellen
            let freeCount = 0;
            
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === 1) {
                        freeCount++;
                    }
                }
            }
            
            if (freeCount < minFreeSpace) {
                console.log(`Nicht genug freier Platz (${freeCount}/${minFreeSpace}), verwerfe diese Wandplatzierung.`);
                return false;
            }
            
            return true;
        }
        
        // Sound-Toggle-Button-Handler
        document.getElementById('sound-toggle').addEventListener('click', function() {
            const soundEnabled = audioManager.toggleSound();
            this.textContent = soundEnabled ? 'An' : 'Aus';
            this.style.backgroundColor = soundEnabled ? '#00aa00' : '#aa0000';
        });
    </script>
</body>
</html> 