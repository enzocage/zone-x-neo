<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone X - 2D Fallback</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            color: white;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #game-canvas {
            display: block;
            background-color: #000022;
        }
        
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            z-index: 10;
        }
        
        #ui-container div {
            margin-bottom: 5px;
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 100;
        }
        
        #start-screen h1 {
            color: #00ff00;
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        #start-screen p {
            color: white;
            margin-bottom: 10px;
            max-width: 600px;
            text-align: center;
        }
        
        #start-button {
            background-color: #00aa00;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #start-button:hover {
            background-color: #00cc00;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="ui-container">
            <div id="lives">Leben: <span id="lives-count">5</span></div>
            <div id="blocks">Blocks: <span id="blocks-count">15</span></div>
            <div id="plutonium">Plutonium übrig: <span id="plutonium-count">5</span></div>
            <div id="score">Punkte: <span id="score-count">0</span></div>
            <div id="timer" class="hidden">Timer: <span id="timer-count">20</span></div>
        </div>
        
        <div id="start-screen">
            <h1>Zone X</h1>
            <p>Rasterbasiertes 2D-Spiel mit 64x32 Grid und Level-Progression.</p>
            <p>Sammle alle Plutonium-Elemente und bringe sie zu den Tonnen. Erreiche dann den Ausgang.</p>
            <p>Steuerung: W, A, S, D zum Bewegen, Leertaste zum Platzieren von Blocks, Mausrad zum Zoomen.</p>
            
            <!-- Auswahl zwischen normalem Level und Zufallslevel -->
            <div class="level-type-selection" style="margin: 20px 0;">
                <label style="margin-right: 10px; color: white;">Level-Typ:</label>
                <button id="standard-level-btn" class="selected-btn" style="background-color: #00aa00; color: white; border: none; padding: 5px 10px; margin-right: 5px; border-radius: 3px; cursor: pointer;">Standard Level</button>
                <button id="random-level-btn" style="background-color: #555; color: white; border: none; padding: 5px 10px; margin-right: 5px; border-radius: 3px; cursor: pointer;">Zufallslevel</button>
                <button id="journey-level-btn" style="background-color: #555; color: white; border: none; padding: 5px 10px; margin-right: 5px; border-radius: 3px; cursor: pointer;">Level-Reise</button>
            </div>
            
            <!-- Dropdown für Standardlevel -->
            <div id="standard-level-options" class="level-selection" style="margin: 20px 0;">
                <label for="level-select" style="margin-right: 10px; color: white;">Level auswählen:</label>
                <select id="level-select" style="padding: 5px; border-radius: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <option value="1">Level 1</option>
                    <option value="2">Level 2</option>
                    <option value="3">Level 3</option>
                    <option value="4">Level 4</option>
                    <option value="5">Level 5</option>
                    <option value="6">Level 6</option>
                    <option value="7">Level 7</option>
                    <option value="8">Level 8</option>
                    <option value="9">Level 9</option>
                    <option value="10">Level 10</option>
                    <option value="11">Level 11</option>
                </select>
            </div>
            
            <!-- Einstellungen für Zufallslevel -->
            <div id="random-level-options" class="level-selection" style="margin: 20px 0; display: none; max-width: 400px;">
                <div style="text-align: left; margin-bottom: 15px; color: #00ff00;">Zufallslevel-Einstellungen:</div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="wall-count" style="color: white; text-align: left; width: 180px;">Wandelemente:</label>
                    <input type="number" id="wall-count" min="50" max="500" value="150" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="50" max="500" value="150" id="wall-count-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="enemy-count" style="color: white; text-align: left; width: 180px;">Gegner:</label>
                    <input type="number" id="enemy-count" min="1" max="20" value="7" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="1" max="20" value="7" id="enemy-count-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="block-count" style="color: white; text-align: left; width: 180px;">Mats:</label>
                    <input type="number" id="block-count" min="5" max="50" value="20" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="5" max="50" value="20" id="block-count-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="barrel-count" style="color: white; text-align: left; width: 180px;">Tonnen:</label>
                    <input type="number" id="barrel-count" min="1" max="10" value="3" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="1" max="10" value="3" id="barrel-count-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="plutonium-count" style="color: white; text-align: left; width: 180px;">Plutonium:</label>
                    <input type="number" id="plutonium-count" min="1" max="10" value="5" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="1" max="10" value="5" id="plutonium-count-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
            </div>
            
            <!-- Einstellungen für Level-Reise -->
            <div id="journey-level-options" class="level-selection" style="margin: 20px 0; display: none; max-width: 400px;">
                <div style="text-align: left; margin-bottom: 15px; color: #00ff00;">Level-Reise Einstellungen:</div>
                <p style="color: white; text-align: left; margin-bottom: 15px;">
                    Beginne mit einem kleinen Spielfeld (16x9) und steigere dich von Level zu Level um jeweils 10% in der Größe.
                    Die Anzahl der Spielelemente wird automatisch an die Größe des Spielfeldes angepasst.
                </p>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="journey-max-level" style="color: white; text-align: left; width: 180px;">Max. Anzahl Level:</label>
                    <input type="number" id="journey-max-level" min="5" max="20" value="10" style="width: 60px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                    <input type="range" min="5" max="20" value="10" id="journey-max-level-slider" style="flex-grow: 1; margin-left: 10px;">
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <label for="journey-difficulty" style="color: white; text-align: left; width: 180px;">Schwierigkeitsgrad:</label>
                    <select id="journey-difficulty" style="width: 150px; padding: 3px; background-color: #333; color: white; border: 1px solid #555;">
                        <option value="easy">Leicht</option>
                        <option value="medium" selected>Mittel</option>
                        <option value="hard">Schwer</option>
                    </select>
                </div>
            </div>
            
            <!-- Audio-Einstellungen -->
            <div style="margin: 20px 0;">
                <label for="sound-toggle" style="color: white; margin-right: 10px;">Sound:</label>
                <button id="sound-toggle" style="background-color: #00aa00; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">An</button>
            </div>
            
            <button id="start-button">Spiel starten</button>
        </div>
    </div>
    
    <script>
        // Grundlegende Konstanten
        let GRID_WIDTH = 64;
        let GRID_HEIGHT = 32;
        const CELL_SIZE = 20; // Pixel pro Zelle - kleiner, um mehr Platz zu haben
        
        // Audio-System mit Web Audio API
        class AudioManager {
            constructor() {
                this.sounds = {};
                this.audioFiles = {}; // Für externe Audio-Dateien
                this.soundEnabled = true;
                this.audioContext = null;
                this.masterGain = null;
                this.lastSoundPlayed = "-";
                
                // Keine Debug-Elemente mehr vorhanden, also entferne die Referenzen
                this.audioStatus = null;
                this.audioContextState = null;
                this.lastSoundEl = null;
                this.volumeLevel = null;
                
                // Log-Nachricht statt UI-Update
                console.log("Audio-Status: Warte auf Benutzerinteraktion...");
                
                // Warte auf Benutzerinteraktion, bevor Audio initialisiert wird
                document.addEventListener('click', () => this.initAudio(), { once: true });
                document.addEventListener('keydown', () => this.initAudio(), { once: true });
                
                // Test-Sound-Button entfernt, daher diese Zeile entfernen
            }
            
            updateAudioStatus(status) {
                // Nur noch Logging, kein UI-Update mehr
                console.log("Audio-Status:", status);
            }
            
            updateLastSound(sound) {
                this.lastSoundPlayed = sound;
                console.log("Letzter Sound:", sound);
            }
            
            initAudio() {
                try {
                    if (this.audioContext) {
                        this.updateAudioStatus("Audio bereits initialisiert");
                        return; // Bereits initialisiert
                    }
                    
                    this.updateAudioStatus("Initialisiere Web Audio API...");
                    
                    // AudioContext erstellen
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext();
                    
                    // Master-Volume erstellen
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.5; // 50% Lautstärke
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Keine UI-Updates mehr für audioContextState
                    console.log("Audio Context State:", this.audioContext.state);
                    
                    this.updateAudioStatus("Audio initialisiert, Status: " + this.audioContext.state);
                    
                    // Status bei Änderung aktualisieren
                    this.audioContext.onstatechange = () => {
                        // Keine UI-Updates mehr für audioContextState
                        console.log("Audio Context State geändert:", this.audioContext.state);
                        this.updateAudioStatus("Audio-Status geändert: " + this.audioContext.state);
                    };
                    
                    // Test-Sound abspielen
                    setTimeout(() => this.playTestSound(), 500);
                    
                    return true;
                } catch (error) {
                    this.updateAudioStatus("Fehler bei Audio-Initialisierung: " + error.message);
                    console.error("Audio-Initialisierungsfehler:", error);
                    return false;
                }
            }
            
            playTestSound() {
                if (!this.audioContext) {
                    this.initAudio();
                    if (!this.audioContext) {
                        this.updateAudioStatus("Kann Test-Sound nicht abspielen: AudioContext nicht verfügbar");
                        return;
                    }
                }
                
                try {
                    // Starten/Fortsetzen des AudioContext falls nötig
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    this.updateAudioStatus("Spiele Test-Sound...");
                    
                    // Einfacher Oszillator für Test-Sound
                    const oscillator = this.audioContext.createOscillator();
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime); // A4
                    
                    // Gain-Node für Envelope
                    const gainNode = this.audioContext.createGain();
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.05);
                    gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.5);
                    
                    // Verbindungen herstellen
                    oscillator.connect(gainNode);
                    gainNode.connect(this.masterGain);
                    
                    // Sound abspielen
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.5);
                    
                    this.updateLastSound("Test-Sound (440Hz)");
                    this.updateAudioStatus("Test-Sound gespielt");
                    
                    setTimeout(() => {
                        this.updateAudioStatus("Bereit");
                    }, 1000);
                    
                    return true;
                } catch (error) {
                    this.updateAudioStatus("Fehler beim Abspielen des Test-Sounds: " + error.message);
                    console.error("Test-Sound-Fehler:", error);
                    return false;
                }
            }
            
            playSound(soundName) {
                if (!this.soundEnabled) {
                    this.updateAudioStatus("Sound deaktiviert: " + soundName);
                    return false;
                }
                
                if (!this.audioContext) {
                    this.updateAudioStatus("AudioContext nicht initialisiert. Initialisiere...");
                    if (!this.initAudio()) {
                        return false;
                    }
                }
                
                // Starten/Fortsetzen des AudioContext falls nötig
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                try {
                    // Einfache Sound-Definitionen basierend auf dem Soundnamen
                    const soundDefs = {
                        'move': { freq: 200, duration: 0.1, type: 'sine' },
                        'placeBlock': { freq: 300, duration: 0.2, type: 'square' },
                        'collectPlutonium': { freq: [400, 600], duration: 0.3, type: 'sawtooth' },
                        'depositPlutonium': { freq: [600, 400], duration: 0.3, type: 'sine' },
                        'collectBlock': { freq: 250, duration: 0.15, type: 'sine' },
                        'enemyCollision': { freq: [100, 80], duration: 0.4, type: 'sawtooth' },
                        'levelComplete': { freq: [400, 600, 800], duration: 0.7, type: 'sine' },
                        'gameOver': { freq: [300, 200, 100], duration: 1.0, type: 'sine' },
                        'gameStart': { freq: [300, 400, 500], duration: 0.8, type: 'triangle' },
                        'timerWarning': { freq: 800, duration: 0.2, type: 'square' },
                        // Neuer dramatischer Timer-Tick-Sound
                        'timerTick': { freq: [350, 250], duration: 0.2, type: 'sine' }
                    };
                    
                    const soundDef = soundDefs[soundName];
                    if (!soundDef) {
                        this.updateAudioStatus("Unbekannter Sound: " + soundName);
                        return false;
                    }
                    
                    // Sound basierend auf der Definition erzeugen
                    if (Array.isArray(soundDef.freq)) {
                        // Mehrere Frequenzen nacheinander für komplexere Sounds
                        const freqs = soundDef.freq;
                        const segmentDuration = soundDef.duration / freqs.length;
                        
                        for (let i = 0; i < freqs.length; i++) {
                            this.playTone(freqs[i], segmentDuration, soundDef.type, i * segmentDuration);
                        }
                    } else {
                        // Einfacher Ton
                        this.playTone(soundDef.freq, soundDef.duration, soundDef.type);
                    }
                    
                    this.updateLastSound(soundName);
                    return true;
                } catch (error) {
                    this.updateAudioStatus("Fehler beim Abspielen von " + soundName + ": " + error.message);
                    console.error("Sound-Fehler:", error);
                    return false;
                }
            }
            
            playTone(frequency, duration, type = 'sine', startDelay = 0) {
                // Einfacher Oszillator-Sound
                const oscillator = this.audioContext.createOscillator();
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime + startDelay);
                
                // Gain-Node für Envelope
                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime + startDelay);
                gainNode.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + startDelay + 0.05);
                gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + startDelay + duration);
                
                // Verbindungen herstellen
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                // Sound abspielen
                oscillator.start(this.audioContext.currentTime + startDelay);
                oscillator.stop(this.audioContext.currentTime + startDelay + duration);
            }
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                
                if (this.masterGain) {
                    this.masterGain.gain.value = this.soundEnabled ? 0.5 : 0;
                }
                
                this.updateAudioStatus(this.soundEnabled ? "Sound aktiviert" : "Sound deaktiviert");
                console.log("Volume:", this.soundEnabled ? "50%" : "0%");
                
                // Wenn Sound aktiviert wird, einen Testsound abspielen
                if (this.soundEnabled) {
                    setTimeout(() => this.playTestSound(), 100);
                }
                
                return this.soundEnabled;
            }
            
            setVolume(volume) {
                if (this.masterGain) {
                    this.masterGain.gain.value = volume;
                    console.log("Volume:", Math.round(volume * 100) + "%");
                }
            }
            
            // Methode zum Laden und Abspielen externer Audio-Dateien
            playAudioFile(filePath) {
                if (!this.soundEnabled) {
                    this.updateAudioStatus("Sound deaktiviert: " + filePath);
                    return false;
                }
                
                try {
                    this.updateAudioStatus("Versuche Audio-Datei abzuspielen: " + filePath);
                    
                    // Prüfen, ob die Datei bereits geladen wurde
                    if (!this.audioFiles[filePath]) {
                        const audio = new Audio(filePath);
                        this.audioFiles[filePath] = audio;
                        
                        // Volume setzen entsprechend der Lautstärkeeinstellung
                        if (this.masterGain) {
                            audio.volume = this.masterGain.gain.value;
                        } else {
                            audio.volume = 0.5; // Standard: 50%
                        }
                        
                        console.log(`Audio-Datei geladen: ${filePath}`);
                    }
                    
                    const audio = this.audioFiles[filePath];
                    
                    // Auf Anfang zurücksetzen und abspielen
                    audio.currentTime = 0;
                    const playPromise = audio.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log(`Audio-Datei wird abgespielt: ${filePath}`);
                            this.updateLastSound(filePath);
                            this.updateAudioStatus("Spielt Audio-Datei: " + filePath);
                        }).catch(error => {
                            console.error(`Fehler beim Abspielen der Audio-Datei ${filePath}:`, error);
                            this.updateAudioStatus("Fehler beim Abspielen: " + error.message);
                            
                            // Fallback bei Autoplay-Sperre
                            if (error.name === 'NotAllowedError') {
                                console.warn("Autoplay wurde vom Browser blockiert. Versuche nach Benutzerinteraktion erneut.");
                                
                                const unlockAudio = () => {
                                    this.playAudioFile(filePath);
                                    document.removeEventListener('click', unlockAudio);
                                };
                                
                                document.addEventListener('click', unlockAudio, { once: true });
                            }
                        });
                    }
                    
                    return true;
                } catch (error) {
                    console.error(`Fehler beim Laden/Abspielen der Audio-Datei ${filePath}:`, error);
                    this.updateAudioStatus("Fehler: " + error.message);
                    return false;
                }
            }
        }
        
        // Audio-Manager initialisieren
        const audioManager = new AudioManager();
        
        // Spielzustand
        let currentLevel = 1;
        let maxLevel = 11; // Laut readme.md gibt es 11 CSV-Dateien
        let zoomLevel = 3.0; // Für Mausrad-Zoom
        
        // Farben
        const COLORS = {
            BACKGROUND: '#000022',
            PLAYER: '#00ff00',
            ENEMY: '#ff0000',
            WALL: '#888888',
            PLUTONIUM: '#ffff00',
            BARREL: '#8B4513',
            BLOCK: '#00aaff',
            EXIT: '#ff00ff',
            GRID: '#333333'
        };
        
        // Spielvariablen
        let canvas, ctx;
        let player = { 
            x: 2, 
            y: 2, 
            direction: 0, 
            lastX: 2, 
            lastY: 2,
            // Für gleitende Bewegung
            visualX: 2, 
            visualY: 2,
            moveSpeed: 0.1 // Geschwindigkeit für gleitende Bewegung
        };
        let walls = [];
        let enemies = [];
        let plutonium = [];
        let barrels = [];
        let blocks = [];
        let collectibleBlocks = []; // Aufsammelbare Blocks
        let exit = { x: 15, y: 15 };
        let lives = 5;
        let blocksCount = 15;
        let score = 0;
        let plutoniumTimer = 0;
        let plutoniumCollected = false;
        let exitReached = false;
        let gameRunning = false;
        
        // Input
        let keys = {
            up: false,
            down: false,
            left: false,
            right: false,
            action: false
        };
        
        // CSV-Parser und Level-Loader
        const LEVEL_SYMBOLS = {
            '█': 'wall',         // Wand
            'O': 'start',        // Startposition
            'X': 'exit',         // Ausgang
            'D': 'barrel',       // Tonne
            'K': 'plutonium',    // Plutonium
            'l': 'block',        // Aufsammelbarer Block
            'l/': 'block',       // Aufsammelbarer Block
            'r': 'enemy',        // Gegner
            'R': 'enemy',        // Gegner
            '?': 'bonus',        // Bonus (Leben)
            'ᴗ': 'teleport',     // Teleporter (nicht implementiert)
            'A': 'teleport',     // Teleporter (nicht implementiert)
            'L/': 'block',       // Aufsammelbarer Block
            'M': 'boss',         // Boss (nicht implementiert)
            'I': 'item'          // Item (nicht implementiert)
        };
        
        // Flag für Zufallslevel
        let isRandomLevel = false;
        let isJourneyMode = false;
        let journeyLevel = 1;
        let journeyMaxLevel = 10;
        
        // Initialisierung
        function init() {
            console.log("Initialisiere 2D-Fallback...");
            
            // Canvas einrichten
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            // Canvas an Fenstergröße anpassen
            resizeCanvas();
            
            // Event-Listener
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('wheel', handleMouseWheel); // Zoom mit Mausrad
            
            // Level erstellen
            loadLevel(currentLevel);
            
            // UI aktualisieren
            updateUI();
            
            // Spielschleife starten
            gameRunning = true;
            requestAnimationFrame(gameLoop);
            
            console.log("Spiel initialisiert und gestartet");
        }
        
        // Canvas-Größe anpassen
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // Mausrad-Handler für Zoom
        function handleMouseWheel(e) {
            if (!gameRunning) return;
            
            // Zoom-Faktor ändern
            if (e.deltaY < 0) {
                zoomLevel *= 1.1; // Hineinzoomen
                if (zoomLevel > 3) zoomLevel = 3; // Maximaler Zoom
            } else {
                zoomLevel /= 1.1; // Herauszoomen
                if (zoomLevel < 0.5) zoomLevel = 0.5; // Minimaler Zoom
            }
            
            // Verhindert Scrollen der Seite
            e.preventDefault();
        }
        
        // Level laden
        async function loadLevel(level) {
            console.log(`Level ${level} wird geladen...`);
            
            // Level-spezifische Einstellungen
            resetGame();
            
            // Level-Reise Modus: Größe und Elemente basierend auf dem aktuellen Level berechnen
            if (isJourneyMode) {
                const params = calculateJourneyLevelParameters(level);
                console.log(`Level-Reise Level ${level}: Spielfeldgröße ${params.width}x${params.height}`);
                
                // Spielfeldgröße setzen
                GRID_WIDTH = params.width;
                GRID_HEIGHT = params.height;
                
                // Ausgang anpassen
                exit = { x: GRID_WIDTH - 3, y: GRID_HEIGHT - 3 };
                
                // Zufallslevel mit den berechneten Parametern generieren
                generateJourneyLevel(params);
                
                return;
            }
            
            // Wenn Zufallslevel gewählt wurde, prüfe, ob ein gespeichertes Zufallslevel ausgewählt wurde
            if (isRandomLevel) {
                const savedLevelSelect = document.getElementById('saved-random-level-select');
                
                if (savedLevelSelect && savedLevelSelect.value) {
                    // Ein gespeichertes Zufallslevel wurde ausgewählt
                    console.log(`Gespeichertes Zufallslevel "${savedLevelSelect.value}" wird geladen...`);
                    if (await loadLevelFromFile(`levels/${savedLevelSelect.value}`)) {
                        console.log("Gespeichertes Zufallslevel erfolgreich geladen");
                        return;
                    } else {
                        console.error(`Fehler beim Laden des gespeicherten Zufallslevels "${savedLevelSelect.value}"`);
                        // Fallback: Generiere ein neues Zufallslevel
                    }
                }
                
                // Kein gespeichertes Level ausgewählt oder Laden fehlgeschlagen, generiere ein neues
                console.log("Zufallslevel wird generiert statt CSV-Level zu laden");
                generateRandomAccessibleLevel();
                console.log("Prüfe generierte Arrays: Wände:", walls.length, "Gegner:", enemies.length, 
                        "Plutonium:", plutonium.length, "Tonnen:", barrels.length, 
                        "Aufsammelbare Blöcke:", collectibleBlocks.length);
                return;
            }
            
            // Ansonsten versuche, das Level aus der CSV-Datei zu laden
            if (await loadLevelFromCSV(level)) {
                console.log("CSV-Level erfolgreich geladen");
            } else {
                console.log("Fallback: Automatisch generiertes Level wird verwendet");
                // Fallback-Generierung der Level-Elemente bereits in loadLevelFromCSV erledigt
            }
            
            console.log(`Level ${level} geladen`);
        }

        // Lädt ein Level aus einer CSV-Datei
        async function loadLevelFromFile(filename) {
            try {
                console.log(`Lade Level aus Datei: ${filename}`);
                
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`HTTP-Fehler: ${response.status}`);
                }
                
                const csvText = await response.text();
                if (parseCSVLevel(csvText)) {
                    console.log(`Level aus ${filename} erfolgreich geladen`);
                    return true;
                } else {
                    throw new Error("Fehler beim Parsen des CSV-Levels");
                }
            } catch (error) {
                console.error(`Fehler beim Laden des Levels aus Datei ${filename}:`, error);
                return false;
            }
        }

        // Funktion zum Berechnen der Größe und Elemente für ein Level in der Level-Reise
        function calculateJourneyLevelParameters(level) {
            // Grundgröße: 16x9
            const baseWidth = 16;
            const baseHeight = 9;
            
            // Spielfeldgröße mit 10% Steigerung pro Level
            const growthFactor = 1.0 + (level - 1) * 0.1;
            const width = Math.floor(baseWidth * growthFactor);
            const height = Math.floor(baseHeight * growthFactor);
            
            // Fläche des Spielfeldes (ohne Rahmen)
            const area = (width - 2) * (height - 2);
            
            // Schwierigkeitsgrad aus dem Dropdown-Menü holen
            const difficulty = document.getElementById('journey-difficulty').value;
            let difficultyFactor = 1.0;
            
            // Schwierigkeitsfaktor setzen
            switch (difficulty) {
                case 'easy': difficultyFactor = 0.7; break;
                case 'medium': difficultyFactor = 1.0; break;
                case 'hard': difficultyFactor = 1.3; break;
            }
            
            // Elemente basierend auf der Fläche und dem Schwierigkeitsgrad berechnen
            const wallDensity = 0.15 * difficultyFactor; // 15% der Fläche sind Wände
            const enemyDensity = 0.04 * difficultyFactor; // 4% Gegner 
            const blocksDensity = 0.025; // 2.5% Blöcke
            const barrelCount = Math.max(3, Math.floor(area * 0.005)); // Mindestens 3 Tonnen
            const plutoniumCount = Math.max(5, Math.floor(area * 0.01)); // Mindestens 5 Plutonium
            
            // Berechne die Anzahl der Elemente
            const wallCount = Math.floor(area * wallDensity);
            const enemyCount = Math.floor(area * enemyDensity);
            const blockCount = Math.floor(area * blocksDensity);
            
            return {
                width,
                height,
                wallCount,
                enemyCount,
                blockCount,
                barrelCount,
                plutoniumCount
            };
        }
        
        // Level-Reise Level generieren
        function generateJourneyLevel(params) {
            console.log("Generiere Level-Reise Level mit folgenden Parametern:", params);
            
            // Arrays zurücksetzen
            walls = [];
            enemies = [];
            plutonium = [];
            barrels = [];
            blocks = [];
            collectibleBlocks = [];
            
            // Spieler positionieren
            player.x = 2;
            player.y = 2;
            player.visualX = 2;
            player.visualY = 2;
            player.lastX = 2;
            player.lastY = 2;
            
            // Außenwände erstellen
            createBorderWalls();
            
            // Wandelemente erstellen und Erreichbarkeit sicherstellen
            createAccessibleWalls(params.wallCount);
            
            // Gegner platzieren
            for (let i = 0; i < params.enemyCount; i++) {
                placeRandomElement('enemy');
            }
            
            // Plutonium platzieren
            for (let i = 0; i < params.plutoniumCount; i++) {
                placeRandomElement('plutonium');
            }
            
            // Tonnen platzieren
            for (let i = 0; i < params.barrelCount; i++) {
                placeRandomElement('barrel');
            }
            
            // Blöcke platzieren
            for (let i = 0; i < params.blockCount; i++) {
                placeRandomElement('block');
            }
            
            // Startblöcke setzen
            blocksCount = 15;
            
            console.log("Level-Reise Level erfolgreich generiert");
        }

        // Start-Button-Handler
        document.getElementById('start-button').addEventListener('click', function() {
            console.log("Start-Button geklickt");
            
            // Audio initialisieren (falls noch nicht geschehen)
            if (audioManager.audioContext === null) {
                audioManager.initAudio();
            }
            
            if (isJourneyMode) {
                // Level-Reise starten
                journeyLevel = 1;
                journeyMaxLevel = parseInt(document.getElementById('journey-max-level').value);
                currentLevel = journeyLevel;
                console.log("Level-Reise gestartet:", journeyLevel, "von", journeyMaxLevel);
            } else if (isRandomLevel) {
                // Bei Zufallslevel wird kein Level-Index benötigt
                currentLevel = 1; // Setze trotzdem auf 1, falls später benötigt
                console.log("Zufallslevel ausgewählt");
            } else {
                // Level aus dem Dropdown-Menü holen
                const levelSelect = document.getElementById('level-select');
                currentLevel = parseInt(levelSelect.value);
                console.log("Standard-Level ausgewählt:", currentLevel);
            }
            
            document.getElementById('start-screen').classList.add('hidden');
            
            try {
                // Statt des synthetisierten Tons die WAV-Datei abspielen
                console.log("Spiele Intro-Sound aus Datei...");
                if (audioManager.playAudioFile('sounds/intro.wav')) {
                    console.log("Intro-Sound wird abgespielt");
                } else {
                    // Fallback auf den synthetisierten Ton
                    console.log("Fallback auf synthetisierten Sound");
                    audioManager.playSound('gameStart');
                }
            } catch (e) {
                console.error("Fehler beim Abspielen des Startsounds:", e);
                // Versuche den synthetisierten Ton als Fallback
                try {
                    audioManager.playSound('gameStart');
                } catch (e2) {
                    console.error("Auch Fallback fehlgeschlagen:", e2);
                }
            }
            
            init();
        });
    </script>
</body>
</html> 